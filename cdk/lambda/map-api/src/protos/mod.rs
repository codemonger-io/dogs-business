//! Protocol Buffers representing vector tiles.

// includes the code generated by protobuf_codegen
include!(concat!(env!("OUT_DIR"), "/protos/mod.rs"));

/// Enum variants for [`Value`][vector_tile::tile::Value].
///
/// Implements `Hash` so that different value types can be used as keys in a
/// `HashMap`.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum PropertyValue {
    /// String value corresponding to
    /// [`Value::string_value`][vector::tile::tile::Value::string_value].
    String(String),
    /// `i64` value corresponding to
    /// [`Value::int_value`][vector::tile::tile::Value::int_value].
    I64(i64),
}

impl PropertyValue {
    /// Returns the string value if it is a string, otherwise `None`.
    #[inline]
    pub fn get_string(&self) -> Option<&String> {
        match self {
            PropertyValue::String(s) => Some(s),
            PropertyValue::I64(_) => None,
        }
    }

    /// Returns the `i64` value if it is an `i64`, otherwise `None`.
    #[inline]
    pub fn get_i64(&self) -> Option<i64> {
        match self {
            PropertyValue::String(_) => None,
            PropertyValue::I64(i) => Some(*i),
        }
    }
}

impl From<String> for PropertyValue {
    fn from(value: String) -> Self {
        PropertyValue::String(value)
    }
}

impl From<i64> for PropertyValue {
    fn from(value: i64) -> Self {
        PropertyValue::I64(value)
    }
}

impl From<PropertyValue> for vector_tile::tile::Value {
    fn from(value: PropertyValue) -> Self {
        match value {
            PropertyValue::String(s) => {
                let mut v = Self::new();
                v.set_string_value(s);
                v
            }
            PropertyValue::I64(i) => {
                let mut v = Self::new();
                v.set_int_value(i);
                v
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use vector_tile::tile::{Feature, Layer, Value};

    #[test]
    fn value_can_be_newed() {
        let value = Value::new();
        assert!(value.string_value.is_none());
        assert!(value.float_value.is_none());
        assert!(value.double_value.is_none());
        assert!(value.int_value.is_none());
        assert!(value.uint_value.is_none());
        assert!(value.sint_value.is_none());
        assert!(value.bool_value.is_none());
    }

    #[test]
    fn feature_can_be_newed() {
        let feature = Feature::new();
        assert!(feature.id.is_none());
        assert!(feature.tags.is_empty());
        assert!(feature.type_.is_none());
        assert!(feature.geometry.is_empty());
    }

    #[test]
    fn layer_can_be_newed() {
        let layer = Layer::new();
        assert!(layer.version.is_none());
        assert!(layer.name.is_none());
        assert!(layer.features.is_empty());
        assert!(layer.keys.is_empty());
        assert!(layer.values.is_empty());
        assert!(layer.extent.is_none());
    }

    #[test]
    fn test_string_into_property_value() {
        let s: PropertyValue = "test".to_string().into();
        assert!(matches!(s, PropertyValue::String(s) if s == "test"));
    }

    #[test]
    fn test_i64_into_property_value() {
        let i: PropertyValue = 1.into();
        assert!(matches!(i, PropertyValue::I64(1)));
    }

    #[test]
    fn test_property_value_eq() {
        let s1: PropertyValue = "1".to_string().into();
        let s2: PropertyValue = "2".to_string().into();
        let i1: PropertyValue = 1.into();
        let i2: PropertyValue = 2.into();
        assert!(s1 == s1);
        assert!(s1 != s2);
        assert!(i1 == i1);
        assert!(i1 != i2);
        assert!(s1 != i1);
    }

    #[test]
    fn test_property_value_hash() {
        let mut map = std::collections::HashMap::<PropertyValue, String>::new();
        let s1: PropertyValue = "1".to_string().into();
        let s2: PropertyValue = "2".to_string().into();
        let i1: PropertyValue = 1.into();
        let i2: PropertyValue = 2.into();
        map.insert(s1.clone(), "s1".to_string());
        map.insert(s2.clone(), "s2".to_string());
        map.insert(i1.clone(), "i1".to_string());
        map.insert(i2.clone(), "i2".to_string());
        assert_eq!(map.get(&s1).unwrap(), "s1");
        assert_eq!(map.get(&s2).unwrap(), "s2");
        assert_eq!(map.get(&i1).unwrap(), "i1");
        assert_eq!(map.get(&i2).unwrap(), "i2");
    }

    #[test]
    fn test_property_value_get_string() {
        let s: PropertyValue = "test".to_string().into();
        assert_eq!(s.get_string().unwrap(), "test");

        let i: PropertyValue = 1.into();
        assert!(i.get_string().is_none());
    }

    #[test]
    fn test_property_value_get_i64() {
        let i: PropertyValue = 1.into();
        assert_eq!(i.get_i64().unwrap(), 1);

        let s: PropertyValue = "test".to_string().into();
        assert!(s.get_i64().is_none());
    }

    #[test]
    fn test_property_value_into_vector_tile_value() {
        let s: PropertyValue = "test".to_string().into();
        let value: Value = s.into();
        assert_eq!(value.string_value.unwrap(), "test");
        assert!(value.int_value.is_none());
        assert!(value.float_value.is_none());
        assert!(value.double_value.is_none());
        assert!(value.uint_value.is_none());
        assert!(value.sint_value.is_none());
        assert!(value.bool_value.is_none());

        let i: PropertyValue = 1.into();
        let value: Value = i.into();
        assert_eq!(value.int_value.unwrap(), 1);
        assert!(value.string_value.is_none());
        assert!(value.float_value.is_none());
        assert!(value.double_value.is_none());
        assert!(value.uint_value.is_none());
        assert!(value.sint_value.is_none());
        assert!(value.bool_value.is_none());
    }
}
